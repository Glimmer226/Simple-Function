#!/usr/bin/env python
#encoding=utf-8
"""
authur: james.wen2@emc.com
"""
import time
from multiprocessing import Process
from multiprocessing import Manager
import os

from lib.base.SSHConnection import SSHConnection
from lib.base.RobotLogger import LOG
from lib.taskgroup.Task import Task
from lib.client.LinuxClientRegister import LinuxClientRegister
from lib.server.AvGC import AvGC
from lib.server.AvCP import AvCP
from lib.server.AvHfs import AvHfs
from lib.server.AvTier import AvTier
from lib.client.DataGen import DataGen
from lib.client.Avtar import Avtar
from lib.base.RobotSSHConnection import *


class  TaskGroup():
    '''
    TaskGroup: support execute multi-tasks in one group simultaneously
    '''
    def __init__(self):
        '''
        Constructor for TaskGroup
        '''
        self.__classname=self.__class__.__name__
        #[
        #{'task_obj','process_objs','status','exit_code'},..
        #]
        self.__tasks=[]
        manager = Manager()
        msg = manager.dict()
        LOG.enable_background(os.getpid(), msg)


    def __add_task_op(self,task_obj,op,object_name,*args,**kwargs):
        '''
        Internal function, add operation for one task
        @task_obj: the object of the specified task wich generated by the new_task()
        @op:       String;add_class;add_method;ssh_reconn
                   add_class, add the task to initialize the class and generate the instance
                   add_method,add the task to call the method
                   ssh_reconn,reconnect the ssh connection
        @object_name:String or object
                   while op is add_class means the class name
                   while op is add_method means the method name
                   while op is ssh_reconn means the ssh object
        @args:     the arguments
        @kwargs:   the kw arguments
        @output:   Boolean
        '''
        try:
            result=task_obj.add_ops(op,object_name,*args,**kwargs )
        except Exception,e:
            LOG.error("%s:wait_task_group failed with exception" %(self.__classname))
            LOG.error(str(e))
            return False
        return result
    def __execute_task_func(self,task_obj):
        '''
        Internal function, execute task
        @task_obj: the object of the specified task wich generated by the new_task()
        @output:   Boolean
        '''
        LOG.debug("Into execute_task_func")
        return task_obj.execute_task()

    def __execute_task_back(self,task_obj):
        '''
        Internal function, execute task in backgroud
        @task_obj: the object of the specified task wich generated by the new_task()
        @output:   the Process object
        '''
        p=Process(target=self.__execute_task_func,args=tuple([task_obj,]))
        p.start()
        return p

    def new_task(self):
        '''
        Generate a new task object
        @output:   the new task object
        '''
        try:
            task_obj=Task()
            #{'task_obj','process_objs','status','exit_code'},..
            task_dict={'task_obj':task_obj,'process_objs':None,'status':None,'exit_code':None}
            self.__tasks.append(task_dict)
        except Exception,e:
            LOG.error("%s:new_task failed with exception" %(self.__classname))
            LOG.error(str(e))
            return False 
        return task_obj

    def add_task_class(self,task_obj,class_name,*args,**kargs):
        '''
        Add the class name into the task object
        @argument detail refer __add_task_op()
        @output:   Boolean
        '''
        return self.__add_task_op(task_obj,'add_class',class_name,*args,**kargs )
    def add_task_method(self,task_obj,method_name,*args,**kargs):
        '''
        Add the method name into the task object 
        @argument detail refer __add_task_op()
        @output:   Boolean
        '''
        return self.__add_task_op(task_obj,'add_method',method_name,*args,**kargs )
    def add_task_ssh_reconnect( self,task_obj,ssh):
        '''
        Add the method for ssh reconnection into the task object
        @argument detail refer __add_task_op()
        @output:   Boolean
        '''
        return self.__add_task_op(task_obj,'ssh_reconn',ssh)

    def execute_group(self):
        '''
        Execute all the tasks in this group
        @output:   Boolean
        '''
        try:
            for index in xrange(len(self.__tasks)): 
                LOG.info("Executing task[%d]" %(index))
                task_dict=self.__tasks[index]
                task_obj=task_dict['task_obj']
                process_obj=self.__execute_task_back(task_obj)
                task_dict={'task_obj':task_obj,'process_objs':process_obj,'status':'running','exit_code':255}
                self.__tasks[index]=task_dict
            return True
        except Exception,e:
            LOG.error("%s:execute_group failed with exception" %(self.__classname))
            LOG.error(str(e))
            return False

    def wait_task_group(self):
        '''
        Wait for all the tasks to be completed in this group
        @output:   Boolean
        '''
        try:
            for index in xrange(len(self.__tasks)):
                task_dict=self.__tasks[index]
                p=task_dict['process_objs']
                p.join()
                task_dict['status']='completed'
                task_dict['exit_code']=p.exitcode
                self.__tasks[index]=task_dict
                LOG.info("task[%d] completed with exit_code=%d" %(index,task_dict['exit_code']))
                LOG.log_background_messages(p.pid)
            return True
        except Exception,e:
            LOG.error("%s:wait_task_group failed with exception" %(self.__classname))
            LOG.error(str(e))
            return False
    def is_taskgroup_success(self):
        '''
        Check whether all the tasks are completed successfully
        @output:   Boolean
        '''
        try:
            for index in xrange(len(self.__tasks)):
                task_dict=self.__tasks[index]
                #LOG.info("task[%d] status=%s exit_code=%d" %(index,task_dict['status'],task_dict['exit_code']))
                if task_dict['status'] != 'completed' or task_dict['exit_code'] != 0:
                    LOG.error("task[%d] completed with exit_code=%d" %(index,task_dict['exit_code']))
                    return False
        except Exception,e:
            LOG.error("%s:is_taskgroup_success failed with exception" %(self.__classname))
            LOG.error(str(e))
            return False
        return True
    def get_taskgroup_status(self):
        '''
        Get taskgroup status.
        @output:   String; "Running","Completed","Failed"
        '''
        try:
            status='Completed' 
            for index in xrange(len(self.__tasks)):
                task_dict=self.__tasks[index]
                p=task_dict['process_objs']
                if p.is_alive() == True:
                    return  'Running'
                elif p.exitcode !=0:
                    status='Failed'
        except Exception,e:
            LOG.error("%s:is_taskgroup_success failed with exception :%s" %(self.__classname,str(e)))
            return ''
        return status

if __name__=="__main__":
    hostname="a4dpe828.asl.lab.emc.com"
    #hostname="10.110.192.58"
    hosts=["a4dpe828.asl.lab.emc.com","10.110.192.58"];
    username="admin"
    password="Chang3M3Now."

    LOG.enable_console_log()
    '''
    sshs=[]
    for i in range(2):
        ssh=ssh_connect_to(hosts[i],username,password)
        sshs.append(ssh)

    LOG.info("create checkpoint simultaneously")
    taskgroup=TaskGroup()
    for i in range(2):
        ssh=sshs[i]
        task=taskgroup.new_task()
        taskgroup.add_task_ssh_reconnect(task,ssh)
        taskgroup.add_task_class(task,"AvCP",ssh)
        taskgroup.add_task_method(task,"create_checkpoint")
        #taskgroup.add_task_method(task,"test_multi")

    LOG.info("execute_group")
    taskgroup.execute_group()

    LOG.info("wait_task_group")
    taskgroup.wait_task_group()
    output=taskgroup.is_taskgroup_success()
    LOG.info("is_tasks_successed=%s" %(output))
    '''


    LOG.info("LinuxClientRegister  simultaneously")
    clients=['a4t81d8.datadomain.com','a4t111d2.datadomain.com','a4t111d3.datadomain.com']
    #clients=['a4t81d8.datadomain.com']
    username='root'
    password='changeme'
    sshs=[]
    for i in xrange(len(clients)):
        ssh=interactive_ssh_connect_to(clients[i],username,password,prompt='#')
        sshs.append(ssh)
    taskgroup=TaskGroup()
    for i in xrange(len(clients)):
        ssh=sshs[i]
        task=taskgroup.new_task()
        taskgroup.add_task_ssh_reconnect(task,ssh)
        taskgroup.add_task_class(task,"LinuxClientRegister",ssh)
        taskgroup.add_task_method(task,"client_uninstall")
        taskgroup.add_task_method(task,"client_qadepot_install","7.4.100-242")
        taskgroup.add_task_method(task,"register","a4t81d7.datadomain.com","clients")
    LOG.info("execute_group")
    taskgroup.execute_group()

    LOG.info("wait_task_group")
    taskgroup.wait_task_group()
    output=taskgroup.is_taskgroup_success()
    LOG.info("is_tasks_successed=%s" %(output))
